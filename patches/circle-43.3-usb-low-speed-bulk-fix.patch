From 91075a403fb952f60c83707e56b239e615c6b3f3 Mon Sep 17 00:00:00 2001
From: Rene Stange <rsta2@o2online.de>
Date: Wed, 24 Mar 2021 22:40:05 +0100
Subject: [PATCH] usb: Add workaround for low-speed devices with bulk EPs

There are some low-speed USB devices, which have bulk endpoints. This
is normally not allowed by the USB specification. To be able to use
such a device, we treat these endpoints being interrupt EPs. This has
not been tested on RPi 4 yet.

See: https://github.com/dwhinham/mt32-pi/discussions/102
---
 lib/usb/dwhcixferstagedata.cpp |  1 -
 lib/usb/usbendpoint.cpp        | 26 +++++++++++++++++++++++++-
 lib/usb/xhciendpoint.cpp       | 15 +++++++++++++++
 3 files changed, 40 insertions(+), 2 deletions(-)

diff --git a/lib/usb/dwhcixferstagedata.cpp b/lib/usb/dwhcixferstagedata.cpp
index 32f3f356..cc783a2d 100644
--- a/lib/usb/dwhcixferstagedata.cpp
+++ b/lib/usb/dwhcixferstagedata.cpp
@@ -185,7 +185,6 @@ void CDWHCITransferStageData::TransactionComplete (u32 nStatus, u32 nPacketsLeft
 		if (   (nStatus & DWHCI_HOST_CHAN_INT_NAK)
 		    && m_pURB->IsCompleteOnNAK ())
 		{
-			assert (m_pEndpoint->GetType () == EndpointTypeBulk);
 			assert (m_bIn);
 
 			m_nPackets = 0;		// no data is available, complete transfer
diff --git a/lib/usb/usbendpoint.cpp b/lib/usb/usbendpoint.cpp
index 05a81279..305487c5 100644
--- a/lib/usb/usbendpoint.cpp
+++ b/lib/usb/usbendpoint.cpp
@@ -2,7 +2,7 @@
 // usbendpoint.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2014-2019  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2014-2021  R. Stange <rsta2@o2online.de>
 // 
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -19,6 +19,7 @@
 //
 #include <circle/usb/usbendpoint.h>
 #include <circle/sysconfig.h>
+#include <circle/logger.h>
 #include <assert.h>
 
 CUSBEndpoint::CUSBEndpoint (CUSBDevice *pDevice)
@@ -113,6 +114,29 @@ CUSBEndpoint::CUSBEndpoint (CUSBDevice *pDevice, const TUSBEndpointDescriptor *p
 	}
 #endif
 
+	// workaround for low-speed devices with bulk endpoints,
+	// which is normally forbidden by the USB spec.
+	if (   m_pDevice->GetSpeed () == USBSpeedLow
+	    && m_Type == EndpointTypeBulk)
+	{
+		CLogger::Get ()->Write ("uep", LogWarning, "Device is not fully USB compliant");
+
+		m_Type = EndpointTypeInterrupt;
+
+		if (m_nMaxPacketSize > 8)
+		{
+			m_nMaxPacketSize = 8;
+		}
+
+#if RASPPI <= 3
+#ifdef USE_USB_SOF_INTR
+		m_nInterval = 1;
+#else
+		m_nInterval = 20;
+#endif
+#endif
+	}
+
 #if RASPPI >= 4
 	m_pXHCIEndpoint = new CXHCIEndpoint ((CXHCIUSBDevice *) m_pDevice, pDesc,
 					     (CXHCIDevice *) m_pDevice->GetHost ());
diff --git a/lib/usb/xhciendpoint.cpp b/lib/usb/xhciendpoint.cpp
index fa4e8f30..5a9eb837 100644
--- a/lib/usb/xhciendpoint.cpp
+++ b/lib/usb/xhciendpoint.cpp
@@ -100,6 +100,21 @@ CXHCIEndpoint::CXHCIEndpoint (CXHCIUSBDevice *pDevice, const TUSBEndpointDescrip
 		m_uchInterval = 0;
 	}
 
+	// workaround for low-speed devices with bulk endpoints,
+	// which is normally forbidden by the USB spec.
+	if (   m_pDevice->GetSpeed () == USBSpeedLow
+	    && (m_uchAttributes & 3) == 2)
+	{
+		m_uchAttributes = 3;		// fake interrupt endpoint
+
+		if (m_usMaxPacketSize > 8)
+		{
+			m_usMaxPacketSize = 8;
+		}
+
+		m_uchInterval = ConvertInterval (1, USBSpeedLow);
+	}
+
 	// calculate endpoint ID
 	assert ((m_uchEndpointAddress & 0x0F) >= 1);
 	m_uchEndpointID = (m_uchEndpointAddress & 0x0F) * 2;
