From 68ae9ec6cce5d5c37e21cada0093200f22ef2d77 Mon Sep 17 00:00:00 2001
From: Rene Stange <rsta2@o2online.de>
Date: Sun, 28 Mar 2021 14:55:15 +0200
Subject: [PATCH] soundbasedevice: Add IEC958 (S/PDIF) hardware format

---
 include/circle/soundbasedevice.h | 11 ++++-
 lib/soundbasedevice.cpp          | 85 +++++++++++++++++++++++++++++++-
 2 files changed, 93 insertions(+), 3 deletions(-)

diff --git a/include/circle/soundbasedevice.h b/include/circle/soundbasedevice.h
index 07a6686c..6b254e7c 100644
--- a/include/circle/soundbasedevice.h
+++ b/include/circle/soundbasedevice.h
@@ -2,7 +2,7 @@
 // soundbasedevice.h
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2017-2020  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2017-2021  R. Stange <rsta2@o2online.de>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -28,12 +28,19 @@
 #define SOUND_MAX_SAMPLE_SIZE	(sizeof (u32))
 #define SOUND_MAX_FRAME_SIZE	(SOUND_HW_CHANNELS * SOUND_MAX_SAMPLE_SIZE)
 
+// IEC958 (S/PDIF)
+#define IEC958_FRAMES_PER_BLOCK		192
+#define IEC958_SUBFRAMES_PER_BLOCK	(SOUND_HW_CHANNELS * IEC958_FRAMES_PER_BLOCK)
+#define IEC958_STATUS_BYTES		5
+#define IEC958_B_FRAME_PREAMBLE		0x0F
+
 enum TSoundFormat			/// All supported formats are interleaved little endian
 {
 	SoundFormatUnsigned8,		/// Not supported as hardware format
 	SoundFormatSigned16,
 	SoundFormatSigned24,
 	SoundFormatUnsigned32,		/// Not supported as write format
+	SoundFormatIEC958,		/// Not supported as write format
 	SoundFormatUnknown
 };
 
@@ -168,6 +175,8 @@ class CSoundBaseDevice : public CDevice		/// Base class of sound devices
 	void *m_pCallbackParam;
 
 	CSpinLock m_SpinLock;
+
+	u8 m_uchIEC958Status[IEC958_STATUS_BYTES];
 };
 
 #endif
diff --git a/lib/soundbasedevice.cpp b/lib/soundbasedevice.cpp
index b156239b..d3788495 100644
--- a/lib/soundbasedevice.cpp
+++ b/lib/soundbasedevice.cpp
@@ -2,7 +2,7 @@
 // soundbasedevice.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2017-2020  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2017-2021  R. Stange <rsta2@o2online.de>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -18,6 +18,7 @@
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 #include <circle/soundbasedevice.h>
+#include <circle/macros.h>
 #include <circle/util.h>
 #include <assert.h>
 
@@ -46,6 +47,7 @@ CSoundBaseDevice::CSoundBaseDevice (TSoundFormat HWFormat, u32 nRange32, unsigne
 		break;
 
 	case SoundFormatSigned24:
+	case SoundFormatIEC958:
 		m_nHWSampleSize = sizeof (u32);
 		m_nRangeMin = -(1 << 23)+1;
 		m_nRangeMax = (1 << 23)-1;
@@ -67,6 +69,33 @@ CSoundBaseDevice::CSoundBaseDevice (TSoundFormat HWFormat, u32 nRange32, unsigne
 	}
 
 	m_nHWFrameSize = SOUND_HW_CHANNELS * m_nHWSampleSize;
+
+	if (m_HWFormat == SoundFormatIEC958)
+	{
+		u8 uchFS, uchOrigFS;
+		switch (m_nSampleRate)
+		{
+		case 22050:	uchFS = 4;	uchOrigFS = 11;	break;
+		case 24000:	uchFS = 6;	uchOrigFS = 9;	break;
+		case 32000:	uchFS = 3;	uchOrigFS = 12;	break;
+		case 44100:	uchFS = 0;	uchOrigFS = 15;	break;
+		case 48000:	uchFS = 2;	uchOrigFS = 13;	break;
+		case 88200:	uchFS = 8;	uchOrigFS = 7;	break;
+		case 96000:	uchFS = 10;	uchOrigFS = 5;	break;
+		case 176400:	uchFS = 12;	uchOrigFS = 3;	break;
+		case 192000:	uchFS = 14;	uchOrigFS = 1;	break;
+
+		default:
+			assert (0);
+			break;
+		}
+
+		m_uchIEC958Status[0] = 0b100;	// consumer, PCM, no copyright, no pre-emphasis
+		m_uchIEC958Status[1] = 0;	// category (general mode)
+		m_uchIEC958Status[2] = 0;	// source number, take no account of channel number
+		m_uchIEC958Status[3] = uchFS;	// sampling frequency
+		m_uchIEC958Status[4] = 0b1011 | (uchOrigFS << 4); // 24 bit samples, original freq.
+	}
 }
 
 CSoundBaseDevice::~CSoundBaseDevice (void)
@@ -279,7 +308,8 @@ unsigned CSoundBaseDevice::GetChunk (s16 *pBuffer, unsigned nChunkSize)
 unsigned CSoundBaseDevice::GetChunk (u32 *pBuffer, unsigned nChunkSize)
 {
 	assert (   m_HWFormat == SoundFormatSigned24
-		|| m_HWFormat == SoundFormatUnsigned32);
+		|| m_HWFormat == SoundFormatUnsigned32
+		|| m_HWFormat == SoundFormatIEC958);
 
 	return GetChunkInternal (pBuffer, nChunkSize);
 }
@@ -340,6 +370,18 @@ void CSoundBaseDevice::ConvertSoundFormat (void *pTo, const void *pFrom)
 		*pValue = (u32) llValue;
 		} break;
 
+	case SoundFormatIEC958: {
+		nValue >>= 4;
+		nValue &= 0xFFFFFF0;
+		if (parity32 (nValue))
+		{
+			nValue |= 0x80000000;
+		}
+
+		s32 *pValue = reinterpret_cast<s32 *> (pTo);
+		*pValue = nValue;
+		} break;
+
 	default:
 		assert (0);
 		break;
@@ -382,6 +424,45 @@ unsigned CSoundBaseDevice::GetChunkInternal (void *pBuffer, unsigned nChunkSize)
 		nBytes += m_nHWFrameSize;
 	}
 
+	// insert control channel and parity bits, and preamble into IEC958 block
+	if (m_HWFormat == SoundFormatIEC958)
+	{
+		u32 *pBuffer32 = static_cast<u32 *> (pBuffer);
+
+		unsigned i;
+		for (i = 0; i < nChunkSize; i += IEC958_SUBFRAMES_PER_BLOCK)
+		{
+			unsigned j;
+			for (j = 0; j < IEC958_STATUS_BYTES * 8 * SOUND_HW_CHANNELS; j++)
+			{
+				u32 *pSubFrame = &pBuffer32[i + j];
+
+				unsigned nFrame = j / SOUND_HW_CHANNELS;
+				if (m_uchIEC958Status[nFrame / 8] & BIT(nFrame % 8))
+				{
+					u32 nValue = *pSubFrame;
+
+					nValue |= 0x40000000;
+
+					nValue &= 0x7FFFFFFF;
+					if (parity32 (nValue))
+					{
+						nValue |= 0x80000000;
+					}
+
+					*pSubFrame = nValue;
+				}
+
+				if (nFrame == 0)
+				{
+					*pSubFrame |= IEC958_B_FRAME_PREAMBLE;
+				}
+			}
+		}
+
+		assert (i == nChunkSize);	// nChunkSize must be a multiple of 384
+	}
+
 	if (   m_pCallback != 0
 	    && nQueueBytesAvail < m_nNeedDataThreshold)
 	{
